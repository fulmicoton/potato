var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var res = mod._cached ? mod._cached : mod();
    return res;
}

require.paths = [];
require.modules = {};
require.extensions = [".js",".coffee"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = x + '/package.json';
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

require.define = function (filename, fn) {
    var dirname = require._core[filename]
        ? ''
        : require.modules.path().dirname(filename)
    ;
    
    var require_ = function (file) {
        return require(file, dirname)
    };
    require_.resolve = function (name) {
        return require.resolve(name, dirname);
    };
    require_.modules = require.modules;
    require_.define = require.define;
    var module_ = { exports : {} };
    
    require.modules[filename] = function () {
        require.modules[filename]._cached = module_.exports;
        fn.call(
            module_.exports,
            require_,
            module_,
            module_.exports,
            dirname,
            filename
        );
        require.modules[filename]._cached = module_.exports;
        return module_.exports;
    };
};

if (typeof process === 'undefined') process = {};

if (!process.nextTick) process.nextTick = (function () {
    var queue = [];
    var canPost = typeof window !== 'undefined'
        && window.postMessage && window.addEventListener
    ;
    
    if (canPost) {
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'browserify-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);
    }
    
    return function (fn) {
        if (canPost) {
            queue.push(fn);
            window.postMessage('browserify-tick', '*');
        }
        else setTimeout(fn, 0);
    };
})();

if (!process.title) process.title = 'browser';

if (!process.binding) process.binding = function (name) {
    if (name === 'evals') return require('vm')
    else throw new Error('No such module')
};

if (!process.cwd) process.cwd = function () { return '.' };

if (!process.env) process.env = {};
if (!process.argv) process.argv = [];

require.define("path", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("/core.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "// Generated by CoffeeScript 1.4.0\n(function() {\n  var HardCoded, List, ListOf, Literal, Map, MapOf, Potato, Tuber, delegateTo, error, extend, interfaceToContent, notImplementedError, pick, rextend, utils,\n    __slice = [].slice;\n\n  utils = require('./utils');\n\n  rextend = utils.rextend;\n\n  pick = utils.pick;\n\n  extend = utils.extend;\n\n  interfaceToContent = function(interfas, sectionHandlers) {\n    var extraContent, k, sectionHandler, v;\n    extraContent = {};\n    for (k in interfas) {\n      v = interfas[k];\n      sectionHandler = sectionHandlers[k];\n      if (sectionHandler != null) {\n        rextend(extraContent, sectionHandler(v));\n      } else {\n        extraContent[k] = v;\n      }\n    }\n    return extraContent;\n  };\n\n  Tuber = function(content) {\n    var extendMyself;\n    extendMyself = function(extraInterface) {\n      var extraContent, msg, newContent;\n      extraContent = interfaceToContent(extraInterface, content.__sectionHandlers__);\n      if (this.constructor.THIS_IS_NOT_A_CONSTRUCTOR_DUMMY != null) {\n        msg = \"Do no call 'new YourPotato()'. Instanciation is done via Yourmake()'.\";\n        throw msg;\n      }\n      newContent = rextend({}, content, extraContent);\n      return Tuber(newContent);\n    };\n    extendMyself.THIS_IS_NOT_A_CONSTRUCTOR_DUMMY = true;\n    rextend(extendMyself, content);\n    return extendMyself;\n  };\n\n  delegateTo = function(delegateMember, methodName) {\n    return function() {\n      var member;\n      member = delegateMember.apply(this);\n      return member[methodName].apply(member, arguments);\n    };\n  };\n\n  Potato = Tuber({\n    __sectionHandlers__: {\n      \"static\": function(staticDic) {\n        return staticDic;\n      },\n      properties: function(propertyDic) {\n        return {\n          __potaproperties__: propertyDic\n        };\n      },\n      methods: function(methodDic) {\n        var k, res, v, _fn;\n        res = {\n          __potaproto__: methodDic\n        };\n        _fn = function(k, v) {\n          if (!(res[k] != null)) {\n            return res[k] = function() {\n              var args, self;\n              self = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n              return self[k].apply(self, args);\n            };\n          }\n        };\n        for (k in methodDic) {\n          v = methodDic[k];\n          _fn(k, v);\n        }\n        return res;\n      },\n      components: function(componentDic) {\n        return {\n          __potacompo__: componentDic\n        };\n      },\n      delegates: function(delegateDic) {\n        var delegated_methods, k, v, _fn;\n        delegated_methods = {};\n        _fn = function(k, v) {\n          return delegated_methods[k] = function() {\n            var args, _ref;\n            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n            return (_ref = this[v])[k].apply(_ref, args);\n          };\n        };\n        for (k in delegateDic) {\n          v = delegateDic[k];\n          _fn(k, v);\n        }\n        return {\n          __potaproto__: delegated_methods\n        };\n      }\n    }\n  });\n\n  Potato = Potato({\n    methods: {\n      components: function() {\n        return this.__potato__.components(this);\n      },\n      set: function(data) {\n        var component, componentId, components;\n        if (data.__potato__ != null) {\n          return data;\n        } else {\n          components = this.components();\n          for (componentId in components) {\n            component = components[componentId];\n            if (data[componentId] != null) {\n              this[componentId] = component.set(this[componentId], data[componentId]);\n            }\n          }\n          return this;\n        }\n      },\n      setData: function(data) {\n        var component, componentId, components;\n        components = this.components();\n        for (componentId in components) {\n          component = components[componentId];\n          if (data[componentId] != null) {\n            this[componentId] = component.setData(this[componentId], data[componentId]);\n          }\n        }\n        return this;\n      },\n      copy: function(obj) {\n        return this.__potato__.make(obj);\n      }\n    },\n    \"static\": {\n      type: 'potato',\n      __init__: function(obj) {},\n      make: function(data) {\n        var actualConstructor, newInstance, potato;\n        if (data == null) {\n          data = void 0;\n        }\n        potato = this;\n        actualConstructor = function() {\n          var k, v, _ref, _ref1;\n          _ref = potato.__potacompo__;\n          for (k in _ref) {\n            v = _ref[k];\n            this[k] = v.make();\n          }\n          _ref1 = potato.__potaproperties__;\n          for (k in _ref1) {\n            v = _ref1[k];\n            this[k] = v.make();\n          }\n          return this;\n        };\n        actualConstructor.prototype.__potato__ = potato;\n        extend(actualConstructor.prototype, potato.__potaproto__);\n        newInstance = new actualConstructor;\n        this.__init__(newInstance);\n        if (data != null) {\n          newInstance.set(data);\n        }\n        return newInstance;\n      },\n      makeFromData: function(data) {\n        var obj;\n        obj = this.make();\n        obj.setData(data);\n        return obj;\n      },\n      components: function() {\n        return this.__potacompo__;\n      }\n    }\n  });\n\n  error = function() {\n    var arg, args, _i, _len, _results;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    _results = [];\n    for (_i = 0, _len = args.length; _i < _len; _i++) {\n      arg = args[_i];\n      _results.push(console.log(\"ERROR : \", arg));\n    }\n    return _results;\n  };\n\n  Literal = Tuber({\n    __sectionHandlers__: {},\n    type: 'json',\n    make: function(val) {\n      if (val != null) {\n        return val;\n      } else {\n        return pick(this[\"default\"]);\n      }\n    },\n    fromData: function(val) {\n      return val;\n    },\n    toJSON: function(val) {\n      return JSON.stringify(this.toData(val));\n    },\n    toData: function(val) {\n      return val;\n    },\n    set: function(obj, val) {\n      return val;\n    },\n    setData: function(obj, val) {\n      return this.set(obj, val);\n    },\n    makeFromData: function(data) {\n      return data;\n    }\n  });\n\n  List = Literal({\n    type: 'list',\n    itemType: Literal({\n      \"default\": Literal\n    }),\n    toData: function(obj) {\n      var it, _i, _len, _results;\n      _results = [];\n      for (_i = 0, _len = obj.length; _i < _len; _i++) {\n        it = obj[_i];\n        _results.push(this.itemType.toData(it));\n      }\n      return _results;\n    },\n    add: function(obj, item) {\n      return obj.push(item);\n    },\n    addData: function(obj, data) {\n      var item;\n      item = this.itemType.make(data);\n      return this.add(obj, item);\n    },\n    make: function(data) {\n      var k, _i, _ref;\n      if (data == null) {\n        data = [];\n      }\n      for (k = _i = 0, _ref = data.length; 0 <= _ref ? _i < _ref : _i > _ref; k = 0 <= _ref ? ++_i : --_i) {\n        data[k] = this.itemType.make(data[k]);\n      }\n      return data;\n    },\n    set: function(l, data) {\n      return data;\n    },\n    setData: function(obj, val) {\n      var it, _i, _len;\n      obj.length = 0;\n      for (_i = 0, _len = val.length; _i < _len; _i++) {\n        it = val[_i];\n        this.add(obj, this.itemType.make(it));\n      }\n      return obj;\n    },\n    makeFromData: function(data) {\n      var obj;\n      obj = this.make();\n      obj.setData(data);\n      return obj;\n    }\n  });\n\n  Map = Literal({\n    type: 'map',\n    itemType: Literal,\n    make: function(data) {\n      var newInstance;\n      newInstance = {};\n      if (data != null) {\n        newInstance.set(data);\n      }\n      return newInstance;\n    },\n    toData: function(obj) {\n      var data, k, v;\n      data = {};\n      for (k in obj) {\n        v = obj[k];\n        data[k] = this.__potato__.itemType.toData(v);\n      }\n      return data;\n    },\n    set: function(obj, data) {\n      return data;\n    },\n    setData: function(obj, val) {\n      var k, v, _results;\n      for (k in obj) {\n        v = obj[k];\n        delete obj[k];\n      }\n      _results = [];\n      for (k in val) {\n        v = val[k];\n        _results.push(obj[k] = this.itemType.makeFromData(val));\n      }\n      return _results;\n    },\n    makeFromData: function(data) {\n      var obj;\n      obj = this.make();\n      obj.setData(data);\n      return obj;\n    }\n  });\n\n  ListOf = function(itemType) {\n    return List({\n      itemType: itemType\n    });\n  };\n\n  MapOf = function(itemType) {\n    return Map({\n      itemType: itemType\n    });\n  };\n\n  notImplementedError = function() {\n    throw \"Not Implemented Error\";\n  };\n\n  HardCoded = function(value) {\n    return {\n      make: function() {\n        return pick(value);\n      }\n    };\n  };\n\n  module.exports = {\n    ListOf: ListOf,\n    MapOf: MapOf,\n    notImplementedError: notImplementedError,\n    Literal: Literal,\n    HardCoded: HardCoded,\n    Potato: Potato,\n    Tuber: Tuber\n  };\n\n}).call(this);\n\n//@ sourceURL=/core.js"
));

require.define("/utils.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "// Generated by CoffeeScript 1.4.0\n(function() {\n  var SIMPLE_DICTIONARY_CONSTRUCTOR, SPLIT_ONCE_PER_TYPE, extend, genericSplitOnce, log, mapDict, pick, regexSplitOnce, removeEl, rextend, split, stringSplitOnce, twoRecursiveExtend,\n    __slice = [].slice;\n\n  extend = function() {\n    var dest, extra, extras, k, v, _i, _len;\n    dest = arguments[0], extras = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    for (_i = 0, _len = extras.length; _i < _len; _i++) {\n      extra = extras[_i];\n      for (k in extra) {\n        v = extra[k];\n        dest[k] = v;\n      }\n    }\n    return dest;\n  };\n\n  stringSplitOnce = function(splitter) {\n    return function(s) {\n      var pos;\n      pos = s.indexOf(splitter);\n      if (pos >= 0) {\n        return [s.slice(0, pos), s.slice(pos + splitter.length)];\n      } else {\n        return void 0;\n      }\n    };\n  };\n\n  regexSplitOnce = function(splitter) {\n    return function(s) {\n      var match, matchLength, pos;\n      match = splitter.exec(s);\n      if (match != null) {\n        matchLength = match[0].length;\n        pos = match.index;\n        return [s.slice(0, pos), s.slice(pos + matchLength)];\n      } else {\n        return void 0;\n      }\n    };\n  };\n\n  SPLIT_ONCE_PER_TYPE = {\n    \"string\": stringSplitOnce,\n    \"object\": regexSplitOnce\n  };\n\n  genericSplitOnce = function(splitter) {\n    var typeSpecificSplitOnce;\n    typeSpecificSplitOnce = SPLIT_ONCE_PER_TYPE[typeof splitter];\n    return typeSpecificSplitOnce(splitter);\n  };\n\n  split = function(s, splitter, n) {\n    var chunks, h, splitOnce, splitResult, t;\n    if (n == null) {\n      n = -1;\n    }\n    splitOnce = genericSplitOnce(splitter);\n    chunks = [];\n    while (n !== 1) {\n      splitResult = splitOnce(s);\n      if (splitResult != null) {\n        h = splitResult[0], t = splitResult[1];\n        s = t;\n        chunks.push(h);\n        n -= 1;\n      } else {\n        break;\n      }\n    }\n    chunks.push(s);\n    return chunks;\n  };\n\n  removeEl = function(arr, el, n) {\n    var elId, nbOcc;\n    if (n == null) {\n      n = 1;\n    }\n    nbOcc = n;\n    while (nbOcc !== 0) {\n      elId = arr.indexOf(el);\n      if (elId !== -1) {\n        arr.splice(elId, 1);\n        nbOcc -= 1;\n      } else {\n        return n - nbOcc;\n      }\n    }\n    return n;\n  };\n\n  SIMPLE_DICTIONARY_CONSTRUCTOR = {}.constructor;\n\n  twoRecursiveExtend = function(dest, extra) {\n    var k, v;\n    for (k in extra) {\n      v = extra[k];\n      if ((typeof v) === \"object\" && (v != null) && !(v.length != null) && v.constructor === SIMPLE_DICTIONARY_CONSTRUCTOR) {\n        if (!(dest[k] != null)) {\n          dest[k] = {};\n        }\n        rextend(dest[k], v);\n      } else {\n        dest[k] = v;\n      }\n    }\n    return dest;\n  };\n\n  rextend = function() {\n    var obj, objs, res, _i, _len, _ref;\n    objs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    res = objs[0];\n    _ref = objs.slice(1);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      obj = _ref[_i];\n      twoRecursiveExtend(res, obj);\n    }\n    return res;\n  };\n\n  pick = function(v) {\n    if (typeof v === \"function\") {\n      return v();\n    } else {\n      return v;\n    }\n  };\n\n  mapDict = function(f, c) {\n    var k, res, v;\n    res = {};\n    for (k in c) {\n      v = c[k];\n      res[k] = f(v);\n    }\n    return res;\n  };\n\n  log = function(msg) {\n    return typeof console !== \"undefined\" && console !== null ? console.log(msg) : void 0;\n  };\n\n  module.exports = {\n    extend: extend,\n    mapDict: mapDict,\n    pick: pick,\n    split: split,\n    rextend: rextend,\n    removeEl: removeEl,\n    log: log\n  };\n\n}).call(this);\n\n//@ sourceURL=/utils.js"
));

require.define("/eventcaster.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "// Generated by CoffeeScript 1.4.0\n(function() {\n  var EventCaster, core, utils,\n    __slice = [].slice;\n\n  utils = require('./utils');\n\n  core = require('./core');\n\n  EventCaster = core.Potato({\n    properties: {\n      __listeners: core.Literal({\n        \"default\": function() {\n          return {};\n        }\n      })\n    },\n    \"static\": {\n      __init__: function(obj) {\n        return obj.trigger(\"init\");\n      }\n    },\n    methods: {\n      trigger: function() {\n        var args, callback, evtName, listeners, _i, _len, _results;\n        evtName = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n        listeners = this.__listeners[evtName];\n        if (listeners != null) {\n          listeners = listeners.slice(0);\n          _results = [];\n          for (_i = 0, _len = listeners.length; _i < _len; _i++) {\n            callback = listeners[_i];\n            _results.push(callback.apply(null, args));\n          }\n          return _results;\n        }\n      },\n      bind: function(evtName, callback) {\n        var _ref;\n        this.__listeners[evtName] = (_ref = this.__listeners[evtName]) != null ? _ref : [];\n        return this.__listeners[evtName].push(callback);\n      },\n      unbind: function(evtName, callback) {\n        var callbacks;\n        callbacks = this.__listeners[evtName];\n        if (callbacks != null) {\n          if (callback != null) {\n            utils.removeEl(callbacks, callback, -1);\n            if (callbacks.length === 0) {\n              delete this.__listeners[evtName];\n            }\n          } else {\n            delete this.__listeners[evtName];\n          }\n        }\n        return this;\n      }\n    }\n  });\n\n  module.exports = {\n    EventCaster: EventCaster\n  };\n\n}).call(this);\n\n//@ sourceURL=/eventcaster.js"
));

require.define("/model.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "// Generated by CoffeeScript 1.4.0\n(function() {\n  var Boolean, CollectionOf, Enum, Integer, Model, String, core, eventcaster, model, utils,\n    __slice = [].slice;\n\n  core = require('./core');\n\n  eventcaster = require('./eventcaster');\n\n  utils = require('./utils');\n\n  Integer = core.Literal({\n    type: 'integer',\n    MIN: 0,\n    MAX: 10,\n    STEP: 1,\n    \"default\": 0,\n    validate: function(data) {\n      if ((typeof data) === \"number\" && (data === Math.round(data))) {\n        return {\n          ok: true\n        };\n      } else {\n        return {\n          ok: false,\n          errors: \"\" + data + \" is not an integer\"\n        };\n      }\n    }\n  });\n\n  String = core.Literal({\n    type: 'string',\n    \"default\": \"\",\n    validate: function(data) {\n      if ((typeof data) === \"string\") {\n        return {\n          ok: true\n        };\n      } else {\n        return {\n          ok: false,\n          errors: \"Expected a string.\"\n        };\n      }\n    }\n  });\n\n  Boolean = core.Literal({\n    type: 'boolean',\n    \"default\": false,\n    validate: function(data) {\n      if ((typeof data) === \"boolean\") {\n        return {\n          ok: true\n        };\n      } else {\n        return {\n          ok: false,\n          errors: \"Boolean expected.\"\n        };\n      }\n    }\n  });\n\n  Enum = String({\n    type: 'radio',\n    \"default\": \"yes\",\n    choices: [\n      {\n        id: \"yes\",\n        name: \"yes\"\n      }, {\n        id: \"no\",\n        name: \"no\"\n      }\n    ],\n    validate: function(value) {\n      var choice, _i, _len, _ref;\n      _ref = this.choices;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        choice = _ref[_i];\n        if (choice.id === value) {\n          return {\n            ok: true\n          };\n        }\n      }\n      return {\n        ok: false,\n        errors: \"Enum value <\" + value + \"> not in \" + this.choices + \".\"\n      };\n    }\n  });\n\n  Model = eventcaster.EventCaster({\n    methods: {\n      validate: function() {\n        var args, _ref;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return (_ref = this.__potato__).validate.apply(_ref, args);\n      },\n      destroy: function() {\n        return this.trigger(\"destroy\");\n      },\n      toJSON: function() {\n        return JSON.stringify(this.toData());\n      },\n      toData: function() {\n        var data, k, v, _ref;\n        data = {};\n        _ref = this.components();\n        for (k in _ref) {\n          v = _ref[k];\n          data[k] = v.toData(this[k]);\n        }\n        return data;\n      },\n      copy: function(obj) {\n        return this.__potato__.make(obj);\n      },\n      set: function(data) {\n        var component, componentId, components;\n        if (data.__potato__ != null) {\n          data;\n\n        } else {\n          components = this.components();\n          for (componentId in components) {\n            component = components[componentId];\n            if (data[componentId] != null) {\n              this[componentId] = component.set(this[componentId], data[componentId]);\n            }\n          }\n        }\n        this.trigger(\"change\");\n        return this;\n      },\n      find: function(elDsl) {\n        var head, sep, target;\n        elDsl = elDsl.trim();\n        if (elDsl === \"\") {\n          return this;\n        }\n        if (elDsl[0] === \"@\") {\n          sep = POTATO_SELECTOR_DSL_SEP.exec(elDsl).index;\n          head = elDsl.slice(1, sep);\n          elDsl = elDsl.slice(sep + 1);\n          target = this[head];\n          return target.find(elDsl.slice(1));\n        } else {\n          console.log(\"Selection DSL for model should start with an @\");\n          return null;\n        }\n      },\n      url: function() {}\n    },\n    \"static\": {\n      validate: function(data) {\n        var cid, component, componentValidation, validationResult, _ref;\n        validationResult = {\n          ok: true\n        };\n        _ref = this.components();\n        for (cid in _ref) {\n          component = _ref[cid];\n          componentValidation = component.validate(data[cid]);\n          if (!componentValidation.ok) {\n            validationResult.ok = false;\n            if (!(validationResult.errors != null)) {\n              validationResult.errors = {};\n            }\n            validationResult.errors[cid] = componentValidation.errors;\n          }\n        }\n        return validationResult;\n      },\n      fromJSON: function(json) {\n        var data;\n        data = JSON.parse(json);\n        return this.fromData(data);\n      },\n      fromData: function(data) {\n        var obj;\n        obj = this.make();\n        return this.setData(obj, data);\n      }\n    }\n  });\n\n  CollectionOf = function(itemType) {\n    return Model({\n      components: {\n        __items: core.ListOf(itemType)\n      },\n      methods: {\n        add: function(item) {\n          var _this = this;\n          this.items().push(item);\n          this.trigger(\"add\", item);\n          this.trigger(\"change\");\n          if (item.bind != null) {\n            item.bind(\"change\", function() {\n              return _this.trigger(\"change\");\n            });\n            item.bind(\"destroy\", function() {\n              return _this.remove(item);\n            });\n          }\n          return this;\n        },\n        remove: function(item) {\n          var nbRemovedEl;\n          nbRemovedEl = utils.removeEl(this.__items, item, 1);\n          if (nbRemovedEl > 0) {\n            return this.trigger(\"change\");\n          }\n        },\n        filter: function(predicate) {\n          var el, els, _i, _len, _ref;\n          els = [];\n          _ref = this.items();\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            el = _ref[_i];\n            if (predicate(el)) {\n              els.push(el);\n            }\n          }\n          return els;\n        },\n        items: function() {\n          return this.__items;\n        },\n        item: function(itemId, value) {\n          var selectedItem;\n          selectedItem = this.__items[itemId];\n          if (!(value != null)) {\n            return selectedItem;\n          } else {\n            return this.__items[itemId] = this.components().__items.itemType.set(selectedItem, value);\n          }\n        },\n        setData: function(data) {\n          var itemData, _i, _len;\n          this.__items = [];\n          for (_i = 0, _len = data.length; _i < _len; _i++) {\n            itemData = data[_i];\n            this.addData(itemData);\n          }\n          this.trigger(\"change\");\n          return this;\n        },\n        toData: function() {\n          return this.components().__items.toData(this.__items);\n        },\n        addData: function(itemData) {\n          return this.add(itemType.fromData(itemData));\n        },\n        size: function() {\n          return this.__items.length;\n        }\n      },\n      \"static\": {\n        validate: function(data) {\n          var item, itemId, itemValidation, validationResult;\n          validationResult = {\n            ok: true\n          };\n          for (itemId in data) {\n            item = data[itemId];\n            itemValidation = this.itemType.validate(item);\n            if (!(itemValidation.ok != null)) {\n              if (!(validationResult.errors != null)) {\n                validationResult.errors = {};\n              }\n              validationResult.errors[itemId] = itemValidation.errors;\n            }\n          }\n          return validationResult;\n        }\n      }\n    });\n  };\n\n  model = {\n    Model: Model,\n    CollectionOf: CollectionOf,\n    Integer: Integer,\n    String: String,\n    Boolean: Boolean,\n    Enum: Enum\n  };\n\n  module.exports = model;\n\n}).call(this);\n\n//@ sourceURL=/model.js"
));

require.define("/view.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "// Generated by CoffeeScript 1.4.0\n(function() {\n  var $, CollectionViewOf, HTMLElement, POTATO_SELECTOR_DSL_SEP, TEMPLATE_PLACEHOLDER_PTN, View, core, eventcaster, hogan, model, utils,\n    __slice = [].slice;\n\n  core = require('./core');\n\n  model = require('./model');\n\n  eventcaster = require('./eventcaster');\n\n  utils = require('./utils');\n\n  hogan = require('hogan.js');\n\n  TEMPLATE_PLACEHOLDER_PTN = /<#\\s*([\\w_]+)\\s*\\/?>/;\n\n  if (!(typeof window !== \"undefined\" && window !== null)) {\n    $ = (function(x) {\n      return x;\n    });\n  } else {\n    $ = window.$;\n  }\n\n  HTMLElement = core.Literal({\n    tagName: '<div>',\n    make: function(elval) {\n      return $(elval != null ? elval : this.tagName);\n    },\n    set: function(self, obj) {\n      return obj;\n    }\n  });\n\n  POTATO_SELECTOR_DSL_SEP = /$|\\ /;\n\n  View = eventcaster.EventCaster({\n    __sectionHandlers__: {\n      template: function(tmpl) {\n        var cid, index, index2, newEl, placeholderMatch, tmpTmpl, whole;\n        while (placeholderMatch = TEMPLATE_PLACEHOLDER_PTN.exec(tmpl)) {\n          whole = placeholderMatch[0], cid = placeholderMatch[1];\n          index = placeholderMatch.index;\n          index2 = index + whole.length;\n          newEl = \"<div id='__ELEMENT_\" + cid + \"'></div>\";\n          tmpTmpl = tmpl.slice(0, index) + newEl + tmpl.slice(index2);\n          tmpl = tmpTmpl;\n        }\n        return {\n          __template__: function() {\n            var args, _ref;\n            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n            return (_ref = hogan.compile(tmpl)).render.apply(_ref, args);\n          }\n        };\n      },\n      events: function(v) {\n        return {\n          __events__: v\n        };\n      },\n      model: function(v) {\n        return {\n          __potaproperties__: {\n            model: v\n          }\n        };\n      },\n      el: function(v) {\n        return {\n          __potaproperties__: {\n            el: HTMLElement({\n              tagName: v\n            })\n          }\n        };\n      }\n    }\n  });\n\n  View = View({\n    template: '',\n    model: model.Model,\n    el: \"<div>\",\n    properties: {\n      __bound__: core.ListOf(core.Potato)\n    },\n    methods: {\n      context: function(parent) {\n        if (parent != null) {\n          return parent;\n        } else {\n          return this;\n        }\n      },\n      destroy: function() {\n        this.unbindEvents();\n        this.el.remove();\n        return this.trigger(\"destroy\");\n      },\n      setModel: function(model) {\n        var cid, component, _ref;\n        this.model = model;\n        _ref = this.components();\n        for (cid in _ref) {\n          component = _ref[cid];\n          if (component.__isView__ != null) {\n            if (model[cid] != null) {\n              this[cid].setModel(model[cid]);\n            }\n          }\n        }\n        return this;\n      },\n      autoRefresh: function() {\n        var _this = this;\n        return this.model.bind(\"change\", function() {\n          return _this.render();\n        });\n      },\n      renderTemplate: function(context) {\n        var component, componentContainer, componentId, _ref, _results;\n        this.el.html(this.__potato__.__template__(context));\n        _ref = this.components();\n        _results = [];\n        for (componentId in _ref) {\n          component = _ref[componentId];\n          if (component.__isView__ != null) {\n            componentContainer = this.el.find(\"#__ELEMENT_\" + componentId);\n            if (componentContainer.size() === 1) {\n              this[componentId].render(context);\n              _results.push(componentContainer.replaceWith(this[componentId].el));\n            } else {\n              _results.push(void 0);\n            }\n          } else {\n            _results.push(void 0);\n          }\n        }\n        return _results;\n      },\n      find: function(elDsl) {\n        var head, sep;\n        elDsl = elDsl.trim();\n        if (elDsl === \"\") {\n          return this;\n        } else if (elDsl[0] === \"@\") {\n          sep = POTATO_SELECTOR_DSL_SEP.exec(elDsl).index;\n          head = elDsl.slice(1, sep);\n          elDsl = elDsl.slice(sep + 1);\n          window.el = this[head];\n          if (elDsl.trim() === \"\") {\n            return this[head];\n          } else {\n            return this[head].find(elDsl);\n          }\n        } else {\n          return this.el.find(elDsl);\n        }\n      },\n      unbindEvents: function() {\n        var el, evt, handler, _i, _len, _ref, _ref1;\n        _ref = this.__bound__;\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          _ref1 = _ref[_i], el = _ref1[0], evt = _ref1[1], handler = _ref1[2];\n          el.unbind(evt, handler);\n        }\n        return this;\n      },\n      bindEvents: function() {\n        var bindEvents, callback, el, elDsl, evt, me, _fn, _ref;\n        this.unbindEvents();\n        me = this;\n        _ref = this.__potato__.__events__;\n        for (elDsl in _ref) {\n          bindEvents = _ref[elDsl];\n          el = this.find(elDsl);\n          _fn = function(callback) {\n            var handler;\n            handler = function() {\n              var args;\n              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n              return callback.call.apply(callback, [me].concat(__slice.call(args)));\n            };\n            el.bind(evt, handler);\n            return me.__bound__.push([el, evt, handler]);\n          };\n          for (evt in bindEvents) {\n            callback = bindEvents[evt];\n            _fn(callback);\n          }\n        }\n        return this;\n      },\n      render: function(parent) {\n        var context;\n        context = this.context(parent);\n        this.renderTemplate(context);\n        this.bindEvents();\n        return this.trigger(\"render\", context);\n      }\n    },\n    \"static\": {\n      keyHandlers: {\n        el: function(content, tagValue) {\n          return content.components.el = HTMLElement({\n            tagName: tagValue\n          });\n        }\n      },\n      loadInto: function($container) {\n        var instance;\n        instance = this.make();\n        instance.el = $($container);\n        instance.render();\n        return instance;\n      },\n      __isView__: true\n    }\n  });\n\n  CollectionViewOf = function(itemType) {\n    return View({\n      el: '<ul>',\n      components: {\n        __items: core.ListOf(itemType)\n      },\n      methods: {\n        addData: function(data) {\n          var newItem;\n          newItem = this.__addViewItem(data);\n          newItem.render();\n          this.el.append(newItem.el);\n          return this;\n        },\n        remove: function(item) {\n          var nbRemovedEl;\n          return nbRemovedEl = utils.removeEl(this.__items, item, 1);\n        },\n        setModel: function(itemModelList) {\n          this.model = itemModelList;\n          return this.__buildItemsFromModel();\n        },\n        __addViewItem: function(model) {\n          var newItem,\n            _this = this;\n          newItem = itemType.make();\n          newItem.setModel(model);\n          this.__items.push(newItem);\n          newItem.bind(\"destroy\", function() {\n            return _this.remove(newItem);\n          });\n          return newItem;\n        },\n        destroyAllItems: function() {\n          var item, _i, _len, _ref;\n          _ref = this.__items;\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            item = _ref[_i];\n            if (item.destroy != null) {\n              item.destroy();\n            }\n          }\n          return this.__items = [];\n        },\n        __buildItemsFromModel: function() {\n          var item, _i, _len, _ref;\n          this.destroyAllItems();\n          _ref = this.model;\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            item = _ref[_i];\n            this.__addViewItem(item);\n          }\n          return this;\n        },\n        __renderItems: function() {\n          var it, _i, _len, _ref, _results;\n          this.el.empty();\n          _ref = this.__items;\n          _results = [];\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            it = _ref[_i];\n            it.render();\n            _results.push(this.el.append(it.el));\n          }\n          return _results;\n        },\n        render: function() {\n          this.__renderItems();\n          return this.trigger(\"render\");\n        }\n      }\n    });\n  };\n\n  module.exports = {\n    View: View,\n    HTMLElement: HTMLElement,\n    CollectionViewOf: CollectionViewOf\n  };\n\n}).call(this);\n\n//@ sourceURL=/view.js"
));

require.define("/node_modules/hogan.js/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./lib/hogan.js\"}\n//@ sourceURL=/node_modules/hogan.js/package.json"
));

require.define("/node_modules/hogan.js/lib/hogan.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*\n *  Copyright 2011 Twitter, Inc.\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n// This file is for use with Node.js. See dist/ for browser files.\n\nvar Hogan = require('./compiler');\nHogan.Template = require('./template').Template;\nmodule.exports = Hogan; \n//@ sourceURL=/node_modules/hogan.js/lib/hogan.js"
));

require.define("/node_modules/hogan.js/lib/compiler.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*\n *  Copyright 2011 Twitter, Inc.\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n(function (Hogan) {\n  // Setup regex  assignments\n  // remove whitespace according to Mustache spec\n  var rIsWhitespace = /\\S/,\n      rQuot = /\\\"/g,\n      rNewline =  /\\n/g,\n      rCr = /\\r/g,\n      rSlash = /\\\\/g,\n      tagTypes = {\n        '#': 1, '^': 2, '/': 3,  '!': 4, '>': 5,\n        '<': 6, '=': 7, '_v': 8, '{': 9, '&': 10\n      };\n\n  Hogan.scan = function scan(text, delimiters) {\n    var len = text.length,\n        IN_TEXT = 0,\n        IN_TAG_TYPE = 1,\n        IN_TAG = 2,\n        state = IN_TEXT,\n        tagType = null,\n        tag = null,\n        buf = '',\n        tokens = [],\n        seenTag = false,\n        i = 0,\n        lineStart = 0,\n        otag = '{{',\n        ctag = '}}';\n\n    function addBuf() {\n      if (buf.length > 0) {\n        tokens.push(new String(buf));\n        buf = '';\n      }\n    }\n\n    function lineIsWhitespace() {\n      var isAllWhitespace = true;\n      for (var j = lineStart; j < tokens.length; j++) {\n        isAllWhitespace =\n          (tokens[j].tag && tagTypes[tokens[j].tag] < tagTypes['_v']) ||\n          (!tokens[j].tag && tokens[j].match(rIsWhitespace) === null);\n        if (!isAllWhitespace) {\n          return false;\n        }\n      }\n\n      return isAllWhitespace;\n    }\n\n    function filterLine(haveSeenTag, noNewLine) {\n      addBuf();\n\n      if (haveSeenTag && lineIsWhitespace()) {\n        for (var j = lineStart, next; j < tokens.length; j++) {\n          if (!tokens[j].tag) {\n            if ((next = tokens[j+1]) && next.tag == '>') {\n              // set indent to token value\n              next.indent = tokens[j].toString()\n            }\n            tokens.splice(j, 1);\n          }\n        }\n      } else if (!noNewLine) {\n        tokens.push({tag:'\\n'});\n      }\n\n      seenTag = false;\n      lineStart = tokens.length;\n    }\n\n    function changeDelimiters(text, index) {\n      var close = '=' + ctag,\n          closeIndex = text.indexOf(close, index),\n          delimiters = trim(\n            text.substring(text.indexOf('=', index) + 1, closeIndex)\n          ).split(' ');\n\n      otag = delimiters[0];\n      ctag = delimiters[1];\n\n      return closeIndex + close.length - 1;\n    }\n\n    if (delimiters) {\n      delimiters = delimiters.split(' ');\n      otag = delimiters[0];\n      ctag = delimiters[1];\n    }\n\n    for (i = 0; i < len; i++) {\n      if (state == IN_TEXT) {\n        if (tagChange(otag, text, i)) {\n          --i;\n          addBuf();\n          state = IN_TAG_TYPE;\n        } else {\n          if (text.charAt(i) == '\\n') {\n            filterLine(seenTag);\n          } else {\n            buf += text.charAt(i);\n          }\n        }\n      } else if (state == IN_TAG_TYPE) {\n        i += otag.length - 1;\n        tag = tagTypes[text.charAt(i + 1)];\n        tagType = tag ? text.charAt(i + 1) : '_v';\n        if (tagType == '=') {\n          i = changeDelimiters(text, i);\n          state = IN_TEXT;\n        } else {\n          if (tag) {\n            i++;\n          }\n          state = IN_TAG;\n        }\n        seenTag = i;\n      } else {\n        if (tagChange(ctag, text, i)) {\n          tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,\n                       i: (tagType == '/') ? seenTag - ctag.length : i + otag.length});\n          buf = '';\n          i += ctag.length - 1;\n          state = IN_TEXT;\n          if (tagType == '{') {\n            if (ctag == '}}') {\n              i++;\n            } else {\n              cleanTripleStache(tokens[tokens.length - 1]);\n            }\n          }\n        } else {\n          buf += text.charAt(i);\n        }\n      }\n    }\n\n    filterLine(seenTag, true);\n\n    return tokens;\n  }\n\n  function cleanTripleStache(token) {\n    if (token.n.substr(token.n.length - 1) === '}') {\n      token.n = token.n.substring(0, token.n.length - 1);\n    }\n  }\n\n  function trim(s) {\n    if (s.trim) {\n      return s.trim();\n    }\n\n    return s.replace(/^\\s*|\\s*$/g, '');\n  }\n\n  function tagChange(tag, text, index) {\n    if (text.charAt(index) != tag.charAt(0)) {\n      return false;\n    }\n\n    for (var i = 1, l = tag.length; i < l; i++) {\n      if (text.charAt(index + i) != tag.charAt(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function buildTree(tokens, kind, stack, customTags) {\n    var instructions = [],\n        opener = null,\n        token = null;\n\n    while (tokens.length > 0) {\n      token = tokens.shift();\n      if (token.tag == '#' || token.tag == '^' || isOpener(token, customTags)) {\n        stack.push(token);\n        token.nodes = buildTree(tokens, token.tag, stack, customTags);\n        instructions.push(token);\n      } else if (token.tag == '/') {\n        if (stack.length === 0) {\n          throw new Error('Closing tag without opener: /' + token.n);\n        }\n        opener = stack.pop();\n        if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {\n          throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);\n        }\n        opener.end = token.i;\n        return instructions;\n      } else {\n        instructions.push(token);\n      }\n    }\n\n    if (stack.length > 0) {\n      throw new Error('missing closing tag: ' + stack.pop().n);\n    }\n\n    return instructions;\n  }\n\n  function isOpener(token, tags) {\n    for (var i = 0, l = tags.length; i < l; i++) {\n      if (tags[i].o == token.n) {\n        token.tag = '#';\n        return true;\n      }\n    }\n  }\n\n  function isCloser(close, open, tags) {\n    for (var i = 0, l = tags.length; i < l; i++) {\n      if (tags[i].c == close && tags[i].o == open) {\n        return true;\n      }\n    }\n  }\n\n  Hogan.generate = function (tree, text, options) {\n    var code = 'var _=this;_.b(i=i||\"\");' + walk(tree) + 'return _.fl();';\n    if (options.asString) {\n      return 'function(c,p,i){' + code + ';}';\n    }\n\n    return new Hogan.Template(new Function('c', 'p', 'i', code), text, Hogan, options);\n  }\n\n  function esc(s) {\n    return s.replace(rSlash, '\\\\\\\\')\n            .replace(rQuot, '\\\\\\\"')\n            .replace(rNewline, '\\\\n')\n            .replace(rCr, '\\\\r');\n  }\n\n  function chooseMethod(s) {\n    return (~s.indexOf('.')) ? 'd' : 'f';\n  }\n\n  function walk(tree) {\n    var code = '';\n    for (var i = 0, l = tree.length; i < l; i++) {\n      var tag = tree[i].tag;\n      if (tag == '#') {\n        code += section(tree[i].nodes, tree[i].n, chooseMethod(tree[i].n),\n                        tree[i].i, tree[i].end, tree[i].otag + \" \" + tree[i].ctag);\n      } else if (tag == '^') {\n        code += invertedSection(tree[i].nodes, tree[i].n,\n                                chooseMethod(tree[i].n));\n      } else if (tag == '<' || tag == '>') {\n        code += partial(tree[i]);\n      } else if (tag == '{' || tag == '&') {\n        code += tripleStache(tree[i].n, chooseMethod(tree[i].n));\n      } else if (tag == '\\n') {\n        code += text('\"\\\\n\"' + (tree.length-1 == i ? '' : ' + i'));\n      } else if (tag == '_v') {\n        code += variable(tree[i].n, chooseMethod(tree[i].n));\n      } else if (tag === undefined) {\n        code += text('\"' + esc(tree[i]) + '\"');\n      }\n    }\n    return code;\n  }\n\n  function section(nodes, id, method, start, end, tags) {\n    return 'if(_.s(_.' + method + '(\"' + esc(id) + '\",c,p,1),' +\n           'c,p,0,' + start + ',' + end + ',\"' + tags + '\")){' +\n           '_.rs(c,p,' +\n           'function(c,p,_){' +\n           walk(nodes) +\n           '});c.pop();}';\n  }\n\n  function invertedSection(nodes, id, method) {\n    return 'if(!_.s(_.' + method + '(\"' + esc(id) + '\",c,p,1),c,p,1,0,0,\"\")){' +\n           walk(nodes) +\n           '};';\n  }\n\n  function partial(tok) {\n    return '_.b(_.rp(\"' +  esc(tok.n) + '\",c,p,\"' + (tok.indent || '') + '\"));';\n  }\n\n  function tripleStache(id, method) {\n    return '_.b(_.t(_.' + method + '(\"' + esc(id) + '\",c,p,0)));';\n  }\n\n  function variable(id, method) {\n    return '_.b(_.v(_.' + method + '(\"' + esc(id) + '\",c,p,0)));';\n  }\n\n  function text(id) {\n    return '_.b(' + id + ');';\n  }\n\n  Hogan.parse = function(tokens, text, options) {\n    options = options || {};\n    return buildTree(tokens, '', [], options.sectionTags || []);\n  },\n\n  Hogan.cache = {};\n\n  Hogan.compile = function(text, options) {\n    // options\n    //\n    // asString: false (default)\n    //\n    // sectionTags: [{o: '_foo', c: 'foo'}]\n    // An array of object with o and c fields that indicate names for custom\n    // section tags. The example above allows parsing of {{_foo}}{{/foo}}.\n    //\n    // delimiters: A string that overrides the default delimiters.\n    // Example: \"<% %>\"\n    //\n    options = options || {};\n\n    var key = text + '||' + !!options.asString;\n\n    var t = this.cache[key];\n\n    if (t) {\n      return t;\n    }\n\n    t = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);\n    return this.cache[key] = t;\n  };\n})(typeof exports !== 'undefined' ? exports : Hogan);\n\n//@ sourceURL=/node_modules/hogan.js/lib/compiler.js"
));

require.define("/node_modules/hogan.js/lib/template.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*\n *  Copyright 2011 Twitter, Inc.\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\nvar Hogan = {};\n\n(function (Hogan, useArrayBuffer) {\n  Hogan.Template = function (renderFunc, text, compiler, options) {\n    this.r = renderFunc || this.r;\n    this.c = compiler;\n    this.options = options;\n    this.text = text || '';\n    this.buf = (useArrayBuffer) ? [] : '';\n  }\n\n  Hogan.Template.prototype = {\n    // render: replaced by generated code.\n    r: function (context, partials, indent) { return ''; },\n\n    // variable escaping\n    v: hoganEscape,\n\n    // triple stache\n    t: coerceToString,\n\n    render: function render(context, partials, indent) {\n      return this.ri([context], partials || {}, indent);\n    },\n\n    // render internal -- a hook for overrides that catches partials too\n    ri: function (context, partials, indent) {\n      return this.r(context, partials, indent);\n    },\n\n    // tries to find a partial in the curent scope and render it\n    rp: function(name, context, partials, indent) {\n      var partial = partials[name];\n\n      if (!partial) {\n        return '';\n      }\n\n      if (this.c && typeof partial == 'string') {\n        partial = this.c.compile(partial, this.options);\n      }\n\n      return partial.ri(context, partials, indent);\n    },\n\n    // render a section\n    rs: function(context, partials, section) {\n      var tail = context[context.length - 1];\n\n      if (!isArray(tail)) {\n        section(context, partials, this);\n        return;\n      }\n\n      for (var i = 0; i < tail.length; i++) {\n        context.push(tail[i]);\n        section(context, partials, this);\n        context.pop();\n      }\n    },\n\n    // maybe start a section\n    s: function(val, ctx, partials, inverted, start, end, tags) {\n      var pass;\n\n      if (isArray(val) && val.length === 0) {\n        return false;\n      }\n\n      if (typeof val == 'function') {\n        val = this.ls(val, ctx, partials, inverted, start, end, tags);\n      }\n\n      pass = (val === '') || !!val;\n\n      if (!inverted && pass && ctx) {\n        ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);\n      }\n\n      return pass;\n    },\n\n    // find values with dotted names\n    d: function(key, ctx, partials, returnFound) {\n      var names = key.split('.'),\n          val = this.f(names[0], ctx, partials, returnFound),\n          cx = null;\n\n      if (key === '.' && isArray(ctx[ctx.length - 2])) {\n        return ctx[ctx.length - 1];\n      }\n\n      for (var i = 1; i < names.length; i++) {\n        if (val && typeof val == 'object' && names[i] in val) {\n          cx = val;\n          val = val[names[i]];\n        } else {\n          val = '';\n        }\n      }\n\n      if (returnFound && !val) {\n        return false;\n      }\n\n      if (!returnFound && typeof val == 'function') {\n        ctx.push(cx);\n        val = this.lv(val, ctx, partials);\n        ctx.pop();\n      }\n\n      return val;\n    },\n\n    // find values with normal names\n    f: function(key, ctx, partials, returnFound) {\n      var val = false,\n          v = null,\n          found = false;\n\n      for (var i = ctx.length - 1; i >= 0; i--) {\n        v = ctx[i];\n        if (v && typeof v == 'object' && key in v) {\n          val = v[key];\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        return (returnFound) ? false : \"\";\n      }\n\n      if (!returnFound && typeof val == 'function') {\n        val = this.lv(val, ctx, partials);\n      }\n\n      return val;\n    },\n\n    // higher order templates\n    ho: function(val, cx, partials, text, tags) {\n      var compiler = this.c;\n      var options = this.options;\n      options.delimiters = tags;\n      var text = val.call(cx, text);\n      text = (text == null) ? String(text) : text.toString();\n      this.b(compiler.compile(text, options).render(cx, partials));\n      return false;\n    },\n\n    // template result buffering\n    b: (useArrayBuffer) ? function(s) { this.buf.push(s); } :\n                          function(s) { this.buf += s; },\n    fl: (useArrayBuffer) ? function() { var r = this.buf.join(''); this.buf = []; return r; } :\n                           function() { var r = this.buf; this.buf = ''; return r; },\n\n    // lambda replace section\n    ls: function(val, ctx, partials, inverted, start, end, tags) {\n      var cx = ctx[ctx.length - 1],\n          t = null;\n\n      if (!inverted && this.c && val.length > 0) {\n        return this.ho(val, cx, partials, this.text.substring(start, end), tags);\n      }\n\n      t = val.call(cx);\n\n      if (typeof t == 'function') {\n        if (inverted) {\n          return true;\n        } else if (this.c) {\n          return this.ho(t, cx, partials, this.text.substring(start, end), tags);\n        }\n      }\n\n      return t;\n    },\n\n    // lambda replace variable\n    lv: function(val, ctx, partials) {\n      var cx = ctx[ctx.length - 1];\n      var result = val.call(cx);\n\n      if (typeof result == 'function') {\n        result = coerceToString(result.call(cx));\n        if (this.c && ~result.indexOf(\"{\\u007B\")) {\n          return this.c.compile(result, this.options).render(cx, partials);\n        }\n      }\n\n      return coerceToString(result);\n    }\n\n  };\n\n  var rAmp = /&/g,\n      rLt = /</g,\n      rGt = />/g,\n      rApos =/\\'/g,\n      rQuot = /\\\"/g,\n      hChars =/[&<>\\\"\\']/;\n\n\n  function coerceToString(val) {\n    return String((val === null || val === undefined) ? '' : val);\n  }\n\n  function hoganEscape(str) {\n    str = coerceToString(str);\n    return hChars.test(str) ?\n      str\n        .replace(rAmp,'&amp;')\n        .replace(rLt,'&lt;')\n        .replace(rGt,'&gt;')\n        .replace(rApos,'&#39;')\n        .replace(rQuot, '&quot;') :\n      str;\n  }\n\n  var isArray = Array.isArray || function(a) {\n    return Object.prototype.toString.call(a) === '[object Array]';\n  };\n\n})(typeof exports !== 'undefined' ? exports : Hogan);\n\n\n//@ sourceURL=/node_modules/hogan.js/lib/template.js"
));

require.define("/form.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "// Generated by CoffeeScript 1.4.0\n(function() {\n  var Checkbox, Field, Form, FormFactory, Input, IntegerForm, JSONForm, PotatoForm, PotatoFormOf, RadioBoxesOf, TextField, core, model, optionid, utils, view, widget,\n    __slice = [].slice;\n\n  utils = require('./utils');\n\n  core = require('./core');\n\n  model = require('./model');\n\n  view = require('./view');\n\n  widget = require('./widget');\n\n  Form = view.View({\n    methods: {\n      edit: function(model) {\n        return this.set_val(model);\n      },\n      val: function(value) {\n        if (!(value != null)) {\n          return this.get_val();\n        } else {\n          return this.set_val(value);\n        }\n      },\n      get_val: function() {\n        throw \"NotImplemented\";\n      },\n      set_val: function(data) {\n        throw \"NotImplemented\";\n      },\n      is_modified: function() {\n        throw \"NotImplemented\";\n      },\n      validate: function() {\n        throw \"NotImplemented\";\n      },\n      print_errors: function(errors) {\n        throw \"NotImplemented\";\n      },\n      render: function(parent) {\n        var context;\n        context = this.context(parent);\n        this.renderTemplate(context);\n        this.bindEvents();\n        if (context !== void 0) {\n          this.set_val(context);\n        }\n        return this.trigger(\"render\", context);\n      },\n      context: function(parent) {\n        return void 0;\n      }\n    }\n  });\n\n  PotatoForm = Form({\n    el: \"<fieldset>\",\n    methods: {\n      get_val: function() {\n        var k, res, v, _ref;\n        res = {};\n        _ref = this.components();\n        for (k in _ref) {\n          v = _ref[k];\n          res[k] = this[k].get_val();\n        }\n        return res;\n      },\n      set_val: function(val) {\n        var changed, k, v, _, _ref;\n        changed = false;\n        _ref = this.components();\n        for (k in _ref) {\n          _ = _ref[k];\n          v = val[k];\n          if (v != null) {\n            if (this[k].set_val(v)) {\n              changed = true;\n            }\n          }\n        }\n        if (changed) {\n          return this.trigger(\"change\");\n        }\n      },\n      validate: function() {\n        \"Validate the form and print out eventual\\nerrors in the form.\\nReturns\\n  - undefined if the value is not valid.\\n  - the value of the model else.\";\n\n        var validation, value;\n        value = this.val();\n        validation = this.__potato__.model.validate(value);\n        if (validation.ok) {\n          this.print_valid();\n          return value;\n        } else {\n          this.print_errors(validation.errors);\n          return void 0;\n        }\n      },\n      print_errors: function(errors) {\n        var k, v, _ref, _results;\n        _ref = this.components();\n        _results = [];\n        for (k in _ref) {\n          v = _ref[k];\n          if (errors[k] != null) {\n            _results.push(this[k].print_errors(errors[k]));\n          } else {\n            _results.push(this[k].print_valid());\n          }\n        }\n        return _results;\n      },\n      print_valid: function() {\n        var k, v, _ref, _results;\n        _ref = this.components();\n        _results = [];\n        for (k in _ref) {\n          v = _ref[k];\n          _results.push(this[k].print_valid());\n        }\n        return _results;\n      }\n    }\n  });\n\n  PotatoFormOf = function(model) {\n    var content, k, label, template, v, _ref, _ref1;\n    content = {};\n    content.components = utils.mapDict((function(model) {\n      return FormFactory.FormOf(model);\n    }), model.components());\n    utils.rextend(content, {\n      \"static\": {\n        model: model\n      }\n    });\n    template = \"\";\n    if (model.label) {\n      template += \"<legend>\" + model.label + \"</legend>\";\n    }\n    _ref = model.components();\n    for (k in _ref) {\n      v = _ref[k];\n      if (v.type !== 'potato') {\n        label = (_ref1 = v.label) != null ? _ref1 : k;\n        template += \"<label>\" + label + \"</label>\\n<#\" + k + \"/>\\n<div style='clear: both;'/>\";\n      } else {\n        template += \"<#\" + k + \"/>\";\n      }\n    }\n    content.template = template;\n    return PotatoForm(content);\n  };\n\n  Input = view.View({\n    el: \"<input type=text>\",\n    methods: {\n      get_val: function() {\n        return this.el.val();\n      },\n      set_val: function(val) {\n        if (val !== this.get_val()) {\n          this.el.val(val);\n          this.trigger(\"change\");\n          return true;\n        } else {\n          return false;\n        }\n      },\n      val: function(value) {\n        if (!(value != null)) {\n          return this.get_val();\n        } else {\n          return this.set_val(value);\n        }\n      }\n    }\n  });\n\n  Field = Form({\n    template: \"<#input/><#error/>\",\n    components: {\n      input: Input,\n      error: view.View({\n        el: \"<div class='error_msg'>\",\n        template: \"{{errors}}\"\n      })\n    },\n    delegates: {\n      get_val: \"input\",\n      set_val: \"input\"\n    },\n    methods: {\n      print_errors: function(errors) {\n        return this.error.render({\n          errors: errors\n        });\n      },\n      print_valid: function() {\n        return this.error.render({\n          errors: \"\"\n        });\n      }\n    },\n    events: {\n      \"@input\": {\n        \"change\": function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return this.trigger.apply(this, [\"change\"].concat(__slice.call(args)));\n        }\n      }\n    }\n  });\n\n  TextField = Field;\n\n  Checkbox = Field({\n    components: {\n      input: Input({\n        el: \"<input type='checkbox'>\",\n        methods: {\n          get_val: function() {\n            return this.el.attr(\"checked\") === \"checked\";\n          },\n          set_val: function(val) {\n            if (val !== this.get_val()) {\n              window.checkbox = this;\n              this.el.attr(\"checked\", val);\n              this.trigger(\"change\");\n              return true;\n            } else {\n              return false;\n            }\n          }\n        },\n        events: {\n          \"@el\": {\n            \"change\": function() {\n              var args;\n              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n              return this.trigger(\"change\");\n            }\n          }\n        }\n      })\n    }\n  });\n\n  IntegerForm = Field({\n    components: {\n      input: Input({\n        el: \"<input type='number' step='1' required='' placeholder=''>\",\n        methods: {\n          onRender: function() {\n            var integerModel, _ref, _ref1;\n            integerModel = this.components().model;\n            this.el.attr(\"min\", integerModel.MIN);\n            this.el.attr(\"max\", integerModel.MAX);\n            this.el.attr(\"step\", integerModel.STEP);\n            return this.el.attr(\"placeholder\", (_ref = (_ref1 = integerModel.help) != null ? _ref1 : integerModel.label) != null ? _ref : \"\");\n          },\n          get_val: function() {\n            return parseInt(this.el.val(), 10);\n          },\n          set_val: function(val) {\n            if (val !== this.get_val()) {\n              this.el.val(\"\" + val);\n              return true;\n            } else {\n              return false;\n            }\n          }\n        }\n      })\n    }\n  });\n\n  JSONForm = Field({\n    components: {\n      input: Input({\n        template: \"{}\",\n        el: \"<textarea>\",\n        methods: {\n          get_val: function() {\n            return JSON.parse(this.el.val());\n          },\n          set_val: function(val) {\n            if (JSON.stringify(val !== this.el.val())) {\n              this.el.val(JSON.stringify(val));\n              this.trigger(\"change\");\n              return true;\n            } else {\n              return false;\n            }\n          }\n        }\n      })\n    }\n  });\n\n  optionid = 0;\n\n  RadioBoxesOf = function(EnumModel) {\n    return Field({\n      \"static\": {\n        model: EnumModel\n      },\n      components: {\n        input: Input({\n          methods: {\n            context: function() {\n              optionid += 1;\n              return {\n                choices: EnumModel.choices,\n                choiceid: \"options#\" + optionid\n              };\n            },\n            selectedInput: function() {\n              var $radiobtn, radiobtn, _i, _len, _ref;\n              _ref = this.el.find(\"input\");\n              for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                radiobtn = _ref[_i];\n                $radiobtn = $(radiobtn);\n                if ($radiobtn.is(':checked')) {\n                  return $radiobtn;\n                }\n              }\n              return null;\n            },\n            get_val: function() {\n              var selectedInput;\n              selectedInput = this.selectedInput();\n              return selectedInput != null ? selectedInput.attr(\"value\") : void 0;\n            },\n            set_val: function(val) {\n              var $radiobtn, checked, radiobtn, _i, _len, _ref;\n              if (val !== this.get_val()) {\n                _ref = this.el.find(\"input\");\n                for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                  radiobtn = _ref[_i];\n                  $radiobtn = $(radiobtn);\n                  checked = $radiobtn.attr(\"value\") === val;\n                  $radiobtn.prop(\"checked\", checked);\n                }\n                return true;\n              } else {\n                return false;\n              }\n            }\n          },\n          template: \"{{#choices}}\\n    <input type = \\\"radio\\\"\\n       id = \\\"{{ id }}\\\"\\n       name = \\\"{{ choiceid }}\\\"\\n       value = \\\"{{ id }}\\\"/>\\n    <label for=\\\"{{ id }}\\\">{{ name }}</label><br/>\\n    {{/choices}}\",\n          el: \"<div class='input-list'>\",\n          properties: {\n            choiceid: model.Integer\n          }\n        })\n      },\n      events: {\n        \"@input @el input\": {\n          \"change\": function() {\n            return this.trigger(\"change\");\n          }\n        }\n      }\n    });\n  };\n\n  FormFactory = core.Tuber({\n    __sectionHandlers__: {},\n    widgets: {\n      list: function(model) {\n        return JSONForm({\n          \"static\": {\n            model: model\n          }\n        });\n      },\n      json: function(model) {\n        return JSONForm({\n          \"static\": {\n            model: model\n          }\n        });\n      },\n      string: function(model) {\n        return TextField({\n          \"static\": {\n            model: model\n          }\n        });\n      },\n      integer: function(model) {\n        return IntegerForm({\n          \"static\": {\n            model: model\n          }\n        });\n      },\n      radio: RadioBoxesOf,\n      \"boolean\": function(model) {\n        return Checkbox({\n          \"static\": {\n            model: model\n          }\n        });\n      },\n      potato: PotatoFormOf\n    },\n    FormOf: function(model) {\n      return this.widgets[model.type](model);\n    }\n  });\n\n  module.exports = {\n    FormFactory: FormFactory,\n    Form: Form,\n    JSONForm: JSONForm\n  };\n\n}).call(this);\n\n//@ sourceURL=/form.js"
));

require.define("/widget.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "// Generated by CoffeeScript 1.4.0\n(function() {\n  var MenuItem, TabMenu, core, model, view;\n\n  core = require('./core');\n\n  model = require('./model');\n\n  view = require('./view');\n\n  MenuItem = model.Model({\n    components: {\n      id: model.String,\n      label: model.String\n    }\n  });\n\n  TabMenu = view.View({\n    help: \"This menu represents a tabmenu. That is a menu\\nwith always exactly one item selected at a time.\\n\\nIf a selected value is supplied by the user,\\nthe event is triggered once on startup.\\n\\nIf a user clicks more than once on a menu item,\\nthe event is only triggered the first time.\",\n    el: \"<ul class='menu'>\",\n    model: core.ListOf(MenuItem),\n    template: \"{{#model}}<li data-item_id='{{id}}'>{{label}}</li>{{/model}}\",\n    methods: {\n      addItem: function(id, label) {\n        this.model.push(MenuItem.make({\n          id: id,\n          label: label\n        }));\n        return this.render();\n      },\n      findItem: function(item_id) {\n        return this.find(\"li[data-item_id='\" + item_id + \"']\");\n      },\n      select: function(item_id) {\n        if (this.selected !== item_id) {\n          this.findItem(this.selected).removeClass(\"selected\");\n          this.findItem(item_id).addClass(\"selected\");\n          this.selected = item_id;\n          return this.trigger(\"select\", item_id);\n        }\n      },\n      onRender: function() {\n        var selected;\n        if (this.findItem(this.selected).length !== 1) {\n          if (this.model.length > 0) {\n            this.selected = this.model[0].item;\n          }\n        }\n        selected = this.selected;\n        this.selected = void 0;\n        return this.select(selected);\n      }\n    },\n    events: {\n      \"li\": {\n        \"click\": function(evt) {\n          var item_id;\n          item_id = evt.currentTarget.dataset.item_id;\n          return this.select(item_id);\n        }\n      }\n    }\n  });\n\n  module.exports = {\n    TabMenu: TabMenu\n  };\n\n}).call(this);\n\n//@ sourceURL=/widget.js"
));

require.define("/model-extras.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "// Generated by CoffeeScript 1.4.0\n(function() {\n  var Email, NonEmptyString, model;\n\n  model = require('./model');\n\n  NonEmptyString = model.String({\n    \"default\": \"something...\",\n    validate: function(data) {\n      var validAsString;\n      validAsString = model.String.validate(data);\n      if (validAsString.ok && data !== \"\") {\n        return {\n          ok: true\n        };\n      } else {\n        return {\n          ok: false,\n          errors: \"Must not be empty.\"\n        };\n      }\n    }\n  });\n\n  Email = model.String({\n    EMAIL_PTN: /^([\\w.-]+)@([\\w.-]+)\\.([a-zA-Z.]{2,6})$/i,\n    validate: function(val) {\n      if (this.EMAIL_PTN.exec(val) != null) {\n        return {\n          ok: true\n        };\n      } else {\n        return {\n          ok: false,\n          errors: 'This is not a valid email address.'\n        };\n      }\n    }\n  });\n\n  module.exports = {\n    Email: Email,\n    NonEmptyString: NonEmptyString\n  };\n\n}).call(this);\n\n//@ sourceURL=/model-extras.js"
));

require.define("/potato.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "// Generated by CoffeeScript 1.4.0\n(function() {\n  var core, eventcaster, form, model, model_extras, utils, view, widget;\n\n  core = require('./core');\n\n  utils = require('./utils');\n\n  eventcaster = require('./eventcaster');\n\n  model = require('./model');\n\n  view = require('./view');\n\n  form = require('./form');\n\n  widget = require('./widget');\n\n  model_extras = require('./model-extras');\n\n  module.exports = utils.extend({}, core, utils, eventcaster, model, view, form, widget, model_extras);\n\n}).call(this);\n\n//@ sourceURL=/potato.js"
));
require("/potato.js");
